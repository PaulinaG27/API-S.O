====================================================================================================
LABORATORIO 3 - MULTIPLICACIÓN DE MATRICES CON GOROUTINES
====================================================================================================
====================================================================================================
BENCHMARK DE RENDIMIENTO - VERSIÓN GO
====================================================================================================
Integrantes:
  • Daniel Agudelo - 1001005358
  • Paulina Garcia - 1000414258
Universidad de Antioquia
Curso: Sistemas Operativos
Fecha: 05/11/2025 22:35:49
====================================================================================================
INFORMACIÓN DEL SISTEMA
====================================================================================================
Sistema operativo: Linux
Kernel: 6.6.87.2-microsoft-standard-WSL2
Arquitectura: x86_64
Procesador: AMD Ryzen 5 7535HS with Radeon Graphics
Núcleos lógicos: 12
Memoria RAM: 7.4Gi
A(450x500) × B(500x600) = C(450x600)
Método utilizado: Heap compartido (memoria compartida implícita)
Explicación:
  • En Go, las goroutines comparten el espacio de memoria del proceso.
  • No se requieren llamadas explícitas como shmget() (no disponibles en Go estándar).
  • El acceso concurrente a la matriz C es seguro porque cada goroutine escribe en filas distintas.
Ejecutando con 1 goroutine...
Tiempo secuencial: 0.196 segundos
Goroutines | Seq (s)        | Par (s)        | Speedup  | Eficiencia
----------|----------------|----------------|----------|-----------
1          | 0.196          | 0.248          | 0.79x    | 79%
2          | 0.196          | 0.130          | 1.51x    | 76%
4          | 0.196          | 0.071          | 2.76x    | 69%
8          | 0.196          | 0.064          | 3.06x    | 38%
16         | 0.196          | 0.057          | 3.44x    | 22%
• Go logra speedup significativo gracias a goroutines ligeras.
• No hay overhead de fork() (como en C), por lo que la eficiencia es más alta.
• El heap compartido actúa como memoria compartida funcional.
• Resultados verificados: secuencial = paralelo.
